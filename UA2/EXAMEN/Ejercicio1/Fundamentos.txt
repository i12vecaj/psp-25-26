/**
Feedback JD - 11/12/2025
Fortalezas: Respuestas claras y estructuradas; buena identificación de la condición de carrera; explicación correcta del modelo Productor–Consumidor en su forma básica; comprensión adecuada de synchronized y de la prioridad de hilos.
Áreas de mejora: La explicación de start() vs run() es incorrecta (start no “asegura que no se inicien varios hilos a la vez”, run no ejecuta “varios hilos al mismo tiempo”); interrupt() está mal entendido (no detiene hilos permanentemente, solo marca el flag y puede despertar a un hilo bloqueado); falta completar varias respuestas (isAlive b; qué ocurre al interrumpir sleep); setPriority() no garantiza ejecución en orden ni que se “ejecute antes”; uso confuso de notify()/notifyAll() en el contexto de interrupciones.
Recomendaciones: Revisar la semántica real de start(), run(), sleep(), interrupt() y los estados del hilo; profundizar en el patrón de interrupción y en cómo manejar correctamente InterruptedException; reforzar el concepto de planificación de hilos y atomicidad; completar siempre las respuestas con los matices técnicos esenciales.
**/

1. Explica la diferencia entre los métodos start() y run() en un hilo.
Pon un ejemplo breve donde se vea la diferencia.

Con el método start() aseguras que no se inicien varios hilos a la vez. 
Sin embargo con el método run pueden ejecutarse varios hilos al mismo tiempo.

Por ejemplo en un banco, si usamos un hilo y lo iniciamos con el start() para que realice un ingreso, aseguramos que ese ingreso va a ser correcto.
Si por el contrario realizamos varios ingresos con varios y ejecutándolos con el run() puede ocurrir que después de los ingresos el resultado no sea el esperado.


2. ¿Qué es una condición de carrera?
Describe qué la provoca y menciona una técnica para evitarla.
Una condición de carrera ocurre cuando varios hilos intentan acceder al mismo recurso a la vez. Para evitarla lo que se debe hacer es sincronizar ese recurso
para que cada hilo entre cuando el anterior haya terminado de utilizarlo.

3. ¿Qué es el modelo Productor–Consumidor?
Indica qué problema resuelve y en qué casos se utiliza.

El modelo productor-consumidor es un modelo por el cual una serie de hilos consumen datos que otros hilos producen.
Resuelve el problema de que los hilos accedan a un recurso el cual no tenga datos en ese instante porque no se le han insertado aun.


4. Observa el siguiente código y responde:

Thread t = new Thread(() -> {
    for (int i = 0; i < 5; i++) {
        System.out.println("A");
    }
});

t.start();

System.out.println(t.isAlive());

a) ¿Qué puede imprimir isAlive()?

Va a imprimir un booleano(true/false) en función de si el hilo t sigue vivo o esta ya en estado muerto.

b) ¿Por qué el resultado puede variar de una ejecución a otra?


5. ¿Para qué sirve el método yield()?
El método yield() lo que hace es que ese hilo cede su ejecución a otro hilo, pasando el anterior a estado preparado. 
 	
Explica por qué no garantiza orden de ejecución entre hilos.
Porque hay veces que el orden de ejecución depende de la carga del sistema o de la plataforma donde ejecutemos el programa.


6. ¿Qué hace el método interrupt() en un hilo?

El método interrupt() lo que hace es detener un hilo permanentemente.

Indica cómo debería reaccionar un hilo bien programado cuando recibe una interrupción.
Pues el hilo se detiene y hasta que no haya un notify() o un notifyAll() que le avise no se ejecuta de nuevo.

7. ¿Qué significa que un método sea synchronized?
Significa que todos los hilos que accedan a ese método lo harán de manera sincronizada y compartiendo el recurso.

Indica cómo afecta a la ejecución cuando varios hilos intentan acceder al mismo recurso.
Pues entraría en ejecución el primer hilo, cuando ese hilo termine inmediatamente se ejecutara el siguiente hilo.

8. Explica la diferencia entre sleep() e interrupt().
La principal diferencia es que con el sleep() paramos el hilo temporalmente mientras que con el interrupt() lo hacemos de forma definitiva.

Indica qué ocurre cuando interrumpimos un hilo que está durmiendo.

9. Dado el siguiente código, indica si produce o no una condición de carrera y por qué:

class Contador {
    public int valor = 0;
}

Contador c = new Contador();

Thread t1 = new Thread(() -> { for(int i = 0; i < 1000; i++) c.valor++; });
Thread t2 = new Thread(() -> { for(int i = 0; i < 1000; i++) c.valor++; });

t1.start();
t2.start();

Si produce una condición de carrera porque no esta sincronizado por lo que el valor de contador no daría el resultado que esperamos

10. Describe qué es la prioridad de un hilo (setPriority()) y cómo afecta realmente a la ejecución.
El setPriority() establece una prioridad entre 1 y 10 a un hilo siendo 1 la mas baja y 10 la mas alta.
Lógicamente a la hora de ejecución el que tenga una prioridad mas alta será el que antes se ejecute

¿Es una garantía de orden? ¿Por qué puede comportarse de forma diferente según el sistema operativo?
No es una garantía de orden, de hecho en ningún momento el asignar una prioridad te asegura que ese hilo se vaya a ejecutar antes que otro con menos.
Además hay sistemas operativos preparados para evitar que un hilo use gran parte de la CPU para el.

