/**
Feedback JD - 11/12/2025
Fortalezas: Respuestas completas y bien estructuradas; buena comprensión general de Productor–Consumidor e identificación correcta de condición de carrera; esfuerzo por razonar cada punto con tus palabras.
Áreas de mejora: Varias definiciones son incorrectas o imprecisas (run() no ejecuta hilos secuenciales, interrupt() no detiene un hilo, synchronized no da “visibilidad al resto de hilos”, sleep vs interrupt incompleto); falta rigor técnico en conceptos de concurrencia; algunas explicaciones son demasiado narrativas y poco exactas.
Recomendaciones: Reforzar la diferencia real entre start() y run(); revisar el funcionamiento de interrupt() y la correcta reacción de un hilo; estudiar visibilidad de memoria y exclusión mutua en synchronized; mejorar precisión técnica evitando metáforas confusas; entrenar con ejemplos de código que ilustren planificación, atomicidad y sincronización.
**/

1. Explica la diferencia entre los métodos start() y run() en un hilo.
Pon un ejemplo breve donde se vea la diferencia.

run() ejecuta los hilos de uno en uno esperando a que estos terminen para ejecutar el siguiente (secuencial) a diferencia de start(), que ejecuta los hilos sin importar si el anterior terminó o no (en paralelo).

2. ¿Qué es una condición de carrera?
Describe qué la provoca y menciona una técnica para evitarla.

Es cuando los hilos tratan de competir por los recursos ya sea al manipularlos o leerlos.
La provocan los hilos al tratar la información no sincronizada.
Se puede evitar si manejamos bien el método de sincronización, hacemos espera de hilos y hacemos buen uso de notifyall


3. ¿Qué es el modelo Productor–Consumidor?
Indica qué problema resuelve y en qué casos se utiliza.

Es un modelo donde tenemos un lado que ofrece un servicio y otro lado que es el que consume (como un camarero y un cliente).
Se suele utilizar cuando necesitas controlar los datos a los que tienen que acceder varios hilos.


4. Observa el siguiente código y responde:

Thread t = new Thread(() -> {
    for (int i = 0; i < 5; i++) {
        System.out.println("A");
    }
});

t.start();

System.out.println(t.isAlive());

a) ¿Qué puede imprimir isAlive()?

Devuelve true o false dependiendo de si el hilo termina o no

b) ¿Por qué el resultado puede variar de una ejecución a otra?

Todo depende de la velocidad a la que se ejecute el for y se ejecute el isAlive().

5. ¿Para qué sirve el método yield()?
Explica por qué no garantiza orden de ejecución entre hilos.

Cede la ejecución a otro hilo.
Porque quien se encarga del orden de ejecución es una parte del sistema operativo.


6. ¿Qué hace el método interrupt() en un hilo?
Indica cómo debería reaccionar un hilo bien programado cuando recibe una interrupción.

Detiene el hilo justo en el momento donde se estaba ejecutando.
Un hilo bien programado debería al reanudar su trabajo cuando salta un error y permite continuar el trabajo del hilo.

7. ¿Qué significa que un método sea synchronized?
Indica cómo afecta a la ejecución cuando varios hilos intentan acceder al mismo recurso.

Significa que el resto de hilos tienen visibilidad a los recursos y métodos que se ejecutan.
Afecta en que los hilos podrán respetar cierto orden a la hora de intentar manipular un mismo dato todos a la vez

8. Explica la diferencia entre sleep() e interrupt().
Indica qué ocurre cuando interrumpimos un hilo que está durmiendo.

sleep() deja el hilo dormido durante una cantidad de tiempo límite mientras que interrupt() lanza una excepción y permite continuar en caso de ser posible con una llamada.

9. Dado el siguiente código, indica si produce o no una condición de carrera y por qué:

class Contador {
    public int valor = 0;
}

Contador c = new Contador();

Thread t1 = new Thread(() -> { for(int i = 0; i < 1000; i++) c.valor++; });
Thread t2 = new Thread(() -> { for(int i = 0; i < 1000; i++) c.valor++; });

t1.start();
t2.start();


Si se produce una condición de carrera ya que ambos hilos intentan acceder a un valor no sincronizado.
Esto genera el problema de que en alguna ocasión, ambos hilos accederán al mismo tiempo intentando sumar.




10. Describe qué es la prioridad de un hilo (setPriority()) y cómo afecta realmente a la ejecución.

¿Es una garantía de orden? ¿Por qué puede comportarse de forma diferente según el sistema operativo?


setPriority() es una manera de decirle al sistema que ciertos hilos tendrán prioridad y TENDRÍAN que ejecutarse unos antes que otros dando la prioridad con valores entre min 0 y max 10.
No, no existe garantía en el orden, esto se debe a que todo depende de como el sistema operativo y la CPU interpreten cual debería de ser orden más acertado.
Se comporta de manera diferente según cómo el sistema operativo maneja estas partes de si mismo.


