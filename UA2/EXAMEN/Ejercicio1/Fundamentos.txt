/**
Feedback JD – 11/12/2025

Fortalezas:
• Identificación parcial de diferencias entre start() y run().
• Reconocimiento del uso de synchronized, wait() y notifyAll() en Productor–Consumidor.
• Correcta idea de que isAlive() devuelve true/false según el estado del hilo.
• Mención de yield(), interrupt() y sleep() con cierta intención.

Áreas de mejora:
• start() no ejecuta hilos secuencialmente; lo hace concurrentemente. run() se ejecuta en el hilo actual, no crea concurrencia.
• La definición de condición de carrera está ausente y necesita explicación sobre acceso simultáneo a recursos compartidos y consecuencias.
• Productor–Consumidor: se mencionan elementos correctos, pero no se explica claramente el flujo de datos ni la coordinación entre productor y consumidor.
• Interrupt() no solo afecta a hilos dormidos, también puede afectar a hilos en wait() o join().
• Explicaciones sobre prioridad y setPriority() son vagas y no reflejan que es solo una sugerencia al scheduler, no una garantía de orden.
• Algunos errores de terminología: "syncronized" → synchronized, "excepción para que se detenga" → InterruptedException.

Recomendaciones:
Revisar las diferencias entre start() y run() con ejemplos prácticos; definir correctamente condición de carrera con un ejemplo; reforzar Productor–Consumidor explicando buffer y coordinación; estudiar el comportamiento real de interrupt(), sleep() y yield(); aclarar que setPriority() es solo una sugerencia al planificador de hilos y que no garantiza orden de ejecución.

**/


1. Explica la diferencia entre los métodos start() y run() en un hilo.
Pon un ejemplo breve donde se vea la diferencia.
- run() hace que el hilo se ejecute hasta que este termine antes de pasar al siguiente, mientras que start() hace que los hilos se ejecuten al mismo tiempo.


2. ¿Qué es una condición de carrera?
Describe qué la provoca y menciona una técnica para evitarla.
- 

3. ¿Qué es el modelo Productor–Consumidor?
Indica qué problema resuelve y en qué casos se utiliza.

- En este modelo, un productor genera datos mientras que los consumidores tratan de acceder a estos, si varios consumidores tratan de acceder a los datos al mismo tiempo habrá errores.

- Para arreglar problemas, utiliza cosas como:
wait() -> Para que espere si no se puede acceder a los datos (porque ya están en uso).

notifyAll() -> Para notificar a los hilos que están esperando que ya pueden acceder a los datos.

syncronized -> Para que solo un hilo pueda acceder a los datos a la vez.

4. Observa el siguiente código y responde:

Thread t = new Thread(() -> {
    for (int i = 0; i < 5; i++) {
        System.out.println("A");
    }
});

t.start();

System.out.println(t.isAlive());

a) ¿Qué puede imprimir isAlive()?
- Imprime si el Thread está todavía en ejecución o si ya ha terminado.

b) ¿Por qué el resultado puede variar de una ejecución a otra?
- El resultado puede cambiar ya que si no ha terminado de ejecutarse para cuando se ejecute isAlive(), indicara que todavía está activo, en cambio, si ya ha terminado indicara que ya no está activo (devuelve true si sigue activo y false si no lo está).


5. ¿Para qué sirve el método yield()?
Explica por qué no garantiza orden de ejecución entre hilos.
- El método yield() hace el hilo actual ceda espacio en el procesador para que otros hilos se ejecuten.

- Este método no garantiza el orden de ejecución entre hilos ya que no hace que otro hilo se ejecute, solo trata de ceder uso del procesador.


6. ¿Qué hace el método interrupt() en un hilo?
Indica cómo debería reaccionar un hilo bien programado cuando recibe una interrupción.
- El método interrupt() hace que el hilo se interrumpa si está "dormido".

- Si el hilo está bien programado, al hacer interrupt() (mientras que este está dormido), este debería detenerse sin dar errores.


7. ¿Qué significa que un método sea synchronized?
Indica cómo afecta a la ejecución cuando varios hilos intentan acceder al mismo recurso.
- Cuando un método es synchronized, los hilos que usen este método no podrán acceder a los datos todos a la vez, si no que tendrán que esperar a que uno termine para que otro puede acceder.

- Si varios hilos intentan acceder a los datos al mismo tiempo, se pueden generar errores, como que uno trate de leer los datos mientras que otro los está modificando, pero con synchrinzed, los hilos tienen que esperar a que los datos esten libres para poder acceder a estos.


8. Explica la diferencia entre sleep() e interrupt().
Indica qué ocurre cuando interrumpimos un hilo que está durmiendo.
- sleep() hace que el hilo espera una determinada cantidad de tiempo antes de seguir (se duerme), en cambio, interrupt() hace que el hilo se interrumpa si este esta dormido.

- Cuando se interrumpe un hilo que esta dormido, se lanza una excepcion para que se detenga.


9. Dado el siguiente código, indica si produce o no una condición de carrera y por qué:

class Contador {
    public int valor = 0;
}

Contador c = new Contador();

Thread t1 = new Thread(() -> { for(int i = 0; i < 1000; i++) c.valor++; });
Thread t2 = new Thread(() -> { for(int i = 0; i < 1000; i++) c.valor++; });

t1.start();
t2.start();


10. Describe qué es la prioridad de un hilo (setPriority()) y cómo afecta realmente a la ejecución.
- setPriority() permite cambiar la prioridad que tienen los hilos para que estos se ejecuten en un cierto orden.

¿Es una garantía de orden? ¿Por qué puede comportarse de forma diferente según el sistema operativo?
- Porque dependiendo del sistema operativo, hay un limite de prioridad distinto.
