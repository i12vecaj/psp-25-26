/**
Feedback JD - 11/12/2025

Fortalezas:
- Buena comprensión general de start() vs run() y synchronized.
- Identificación correcta de condiciones de carrera.
- Reconocimiento conceptual de productor-consumidor y prioridades de hilos.

Áreas de mejora:
- Explicaciones de yield(), interrupt() y sleep() imprecisas.
- Falta detalle en la aplicación práctica de wait()/notify() en productor-consumidor.
- Prioridad de hilos explicada de manera parcial, sin relación clara con el SO.

Recomendaciones:
- Aclarar funcionamiento y diferencias de yield(), interrupt() y sleep().
- Implementar coordinación real con wait()/notify() en productor-consumidor.
- Mejorar precisión en el uso y efecto de setPriority() según el sistema operativo.
**/


1. Explica la diferencia entre los métodos start() y run() en un hilo.
Pon un ejemplo breve donde se vea la diferencia.

-La diferencia entre los métodos es que el método start inicializa el hilo pero prosigue, el método run lo que hace es que
salta directamente al archivo del hilo deteniendo así el proceso principal. Esto es muy usado para la programación concurrente 
o secuencial.

2. ¿Qué es una condición de carrera?
Describe qué la provoca y menciona una técnica para evitarla.

-La condición de carrera es un problema básico que suele ocurrir en la programación concurrente. Provoca que el orden sea impredecible
en la ejecución, esto se soluciona con el synchronized.

3. ¿Qué es el modelo Productor–Consumidor?
Indica qué problema resuelve y en qué casos se utiliza.

-Es un problema de concurrencia en el cual el productor genera los elementos, el consumidor los procesa y el búfer controla si 
puede entrar o no. Esto soluciona que el consumidor no consuma cuando está vacio y coordinar los hilos sin condiciones de carrera.
Se suele usar en colas de tareas, servidores web, app móviles, etc.

4. Observa el siguiente código y responde:

Thread t = new Thread(() -> {
    for (int i = 0; i < 5; i++) {
        System.out.println("A");
    }
});

t.start();

System.out.println(t.isAlive());

a) ¿Qué puede imprimir isAlive()?

-El isAlive() imprime si el hilo está vivo en ese momento, que en este caso debería de estarlo.

b) ¿Por qué el resultado puede variar de una ejecución a otra?

-El resultado puede variar de una ejecución a otra ya que no es lo más optimo dejar hilos vivos sin hacer nada, por lo cual 
debería de comprobarse si algunos de los hilos los cuales no se van a usar estan parados para que estos no consuman recursos.


5. ¿Para qué sirve el método yield()?
Explica por qué no garantiza orden de ejecución entre hilos.

-Un hilo sugiere "ceder el paso" voluntariamente para que otros usen la CPU. No garantiza el orden ya que debería de ponerse
una prioridad.


6. ¿Qué hace el método interrupt() en un hilo?
Indica cómo debería reaccionar un hilo bien programado cuando recibe una interrupción.

-La forma buena de detener un hilo, a diferencia de el stop. Este hilo deberia de interrumpirse dejando pasar a otro hilo con
mayor prihoridad.

7. ¿Qué significa que un método sea synchronized?
Indica cómo afecta a la ejecución cuando varios hilos intentan acceder al mismo recurso.

-Significa que solo un hilo puede entrar a la vez, y esto afecta de tal manera que entra y tiene que esperar pues se queda
ahi parado, y en el momento que alguien le notifique con el notifyAll sigue con su acción.

8. Explica la diferencia entre sleep() e interrupt().
Indica qué ocurre cuando interrumpimos un hilo que está durmiendo.

-El sleep() es para dormir un hilo durante un cierto tiempo y que luego prosiga su actividad, y interrump es para cortarlo 
directamente. Cuando interrumpinos un hilo que ya esta durmiendo este se cierrará y no terminará si tenía que haceer algo después
de estar dormido.

9. Dado el siguiente código, indica si produce o no una condición de carrera y por qué:

class Contador {
    public int valor = 0;
}

Contador c = new Contador();

Thread t1 = new Thread(() -> { for(int i = 0; i < 1000; i++) c.valor++; });
Thread t2 = new Thread(() -> { for(int i = 0; i < 1000; i++) c.valor++; });

t1.start();
t2.start();


- si, en el contador igualar a 0 sin el synchronized ya es lo primero que sabemos que va a dar problemas y si 2 hilos ejecutan 
simultáneamente van a salir valores los cuales no pertenecen al estar haciendose los dos a la vez con el mismo valor, ya que 
van a ir sobreponiendose.

10. Describe qué es la prioridad de un hilo (setPriority()) y cómo afecta realmente a la ejecución.
¿Es una garantía de orden? ¿Por qué puede comportarse de forma diferente según el sistema operativo?

-La prioridad de un hilo es 1, que es el mínimo, y luego 10, que es el máximo. Esto no asegura que se vayan a ejecutar 100%
con la prioridad indicada pero si algun hilo se interrumpe o está esperando, si sabe cual salir a ejecutarse según esta la 
prioridad. Se puede comportar diferente porque si tu tienes un hilo de prihoridad 3 ejecutandose y luego tienes uno esperando de 8
a menos que el de 3 no se pare, no va a saltar el de prioridad 8.
