1. Explica la diferencia entre los métodos start() y run() en un hilo.
Pon un ejemplo breve donde se vea la diferencia.

- Start crea un nuevo hilo y ejecuta el método run en ese hilo separado, run ejecuta el código directamente en el hilo actual,
sin crear un nuevo hilo.

class MiHilo extends Thread {
    public void run() {
        System.out.println("Hilo: " + Thread.currentThread().getName());
    }
}

public class Main {
    public static void main(String[] args) {
        MiHilo h = new MiHilo();
        
        h.start(); 
        h.run();
    }
}

Con h.start obtienes concurrencia real, con h.run no

2. ¿Qué es una condición de carrera?
Describe qué la provoca y menciona una técnica para evitarla.

-Una condición de carrera se produce cuando dos o más procesos compiten por acceso de un recurso, produciendo
inconsistencias, y posibles bloqueos.
-Se soluciona: Bloqueando a nivel de fichero, manejando adecuadamente el flujo y el manejo de errores, usando synchronized
o variables atómicas


3. ¿Qué es el modelo Productor–Consumidor?
Indica qué problema resuelve y en qué casos se utiliza.

- Modelo de comunicación para la programación concurrente unos hilos generan datos y otros los utilizan, comunicándose
a través de un buffer.
- Se usa en casos donde el productor deja de producir hasta que el consumidor utiliza el recurso, y consumidor espera hasta que el productor 
lo genera.


4. Observa el siguiente código y responde:

Thread t = new Thread(() -> {
    for (int i = 0; i < 5; i++) {
        System.out.println("A");
    }
});

t.start();

System.out.println(t.isAlive());

a) ¿Qué puede imprimir isAlive()? 
b) ¿Por qué el resultado puede variar de una ejecución a otra?
- True o False
.

5. ¿Para qué sirve el método yield()?
Explica por qué no garantiza orden de ejecución entre hilos.

- Es una forma de controlar hilos, este metodo sugiere ceder a otros hilos el uso de cpu.
- No garantiza orden porque es solo una sugerencia y el planificador puede ignorarla por diferentes circuntancias 
(por ejemplo que otros hilos no estén listos) además depende del SO.

6. ¿Qué hace el método interrupt() en un hilo?
Indica cómo debería reaccionar un hilo bien programado cuando recibe una interrupción.

- Envia una señal de detención al hilo, pero si este ya esta en sleep, wait o join lanza una excepcion. Lo correcto es usar interrupt y no stop
además de capturar las excepciones.


7. ¿Qué significa que un método sea synchronized?
Indica cómo afecta a la ejecución cuando varios hilos intentan acceder al mismo recurso.

- Significa que solo un hilo puede entrar a la vez a una parte crítica de un objeto, el resto deberá esperar. Con wait y notifyAll se 
manejan las condiciones para que un hilo avance o no.

8. Explica la diferencia entre sleep() e interrupt().
Indica qué ocurre cuando interrumpimos un hilo que está durmiendo.
- Sleep pausa el hilo un tiempo determinado en milisegundos, interrupt es la forma correcta de detener un hilo.
- Si intentas detener un hilo pausado con sleep se lanzará una excepción.

9. Dado el siguiente código, indica si produce o no una condición de carrera y por qué:

class Contador {
    public int valor = 0;
}

Contador c = new Contador();

Thread t1 = new Thread(() -> { for(int i = 0; i < 1000; i++) c.valor++; });
Thread t2 = new Thread(() -> { for(int i = 0; i < 1000; i++) c.valor++; });

t1.start();
t2.start();

Sí hay condición de carrera: c.valor++ no es atómico,  ambos hilos pueden intercalar sus pasos perdiendo incrementos

10. Describe qué es la prioridad de un hilo (setPriority()) y cómo afecta realmente a la ejecución.
¿Es una garantía de orden? ¿Por qué puede comportarse de forma diferente según el sistema operativo?

Es una sugerencia al planificador de hilos para que considere antes a los hilos con prioridad más alta.
No es una orden estricta ni una garantía de ejecución en ningún orden específico y efectivamente se comporta diferente segun el SO.