1. Explica la diferencia entre los métodos start() y run() en un hilo.
Pon un ejemplo breve donde se vea la diferencia.

Ambos métodos hacen que un hilo empiece a trabajar, sin embargo al ejecutarse con run() trabajarán de forma secuencial y al hacerlo con start() lo harán de forma concurrente, explico la diferencia con un ejemplo:

si tenemos una clase que implementa Thread y que tiene la función que sea, por ejemplo una clase empleado que contenga distintas tareas que debe realizar en forma de métodos entre ellos el método run, que es el principal que le dice al hilo lo que hacer, se puede iniciar ya sea con: empleado.run(), esto hará que si instanciamos varios empleados y los arrancamos como hilos trabajarán de forma secuencial, es decir que no podrán trabajar a la vez, cuando uno acabe seguirá otro, sin embargo si hacemos empleado.start(), trabajaran de forma concurrente, que no es lo mismo que paralela pero de está forma si podrán ejecutarse todos a la vez. 

2. ¿Qué es una condición de carrera?
Describe qué la provoca y menciona una técnica para evitarla.

la condición de carrera ocurre cuando varios hilos intentan acceder a la vez a los mismos datos o modificarlos, haciendo que den resultados incorrectos. La principal forma de evitarlo es añadiendo synchronized a los métodos a los que vayan a acceder los hilos, de esta forma: public synchronized void mi_metodo(), esto básicamente hace que cuando hilo entre a una parte del código que use synchronized, esta se bloquee impidiendo la entrada de más hilos, evitando la condición de carrera.


3. ¿Qué es el modelo Productor–Consumidor?
Indica qué problema resuelve y en qué casos se utiliza.

en el modelo productor consumidor básicamente hay una clase que genera datos y los pone en una cola (productor) y otro que usa los recursos o datos en esa cola (consumidor), se suele usar en proyectos que generen datos constantemente. Resuelve el problema de la condición de carrera con los métodos synchronized, wait y notifyAll, si estos métodos no se usan se darán problemas como el consumidor intentando consumir algo de la cola cuando está vacia.

4. Observa el siguiente código y responde:

Thread t = new Thread(() -> {
    for (int i = 0; i < 5; i++) {
        System.out.println("A");
    }
});

t.start();

System.out.println(t.isAlive());

a) ¿Qué puede imprimir isAlive()?
es un booleano, así que imprimirá true si el proceso se está ejecutando o false si ya ha terminado.
b) ¿Por qué el resultado puede variar de una ejecución a otra?
pues la única variación que puede haber es si cuando se llega al print el hilo sigue vivo o no.

5. ¿Para qué sirve el método yield()?
Explica por qué no garantiza orden de ejecución entre hilos.

el método yield hará que un hilo deje de ejecutarse dándole el control al planificador, para dejar su posición a otro hilo.


6. ¿Qué hace el método interrupt() en un hilo?
Indica cómo debería reaccionar un hilo bien programado cuando recibe una interrupción.

el método interrupt detiene la ejecución de un hilo, si está bien programado se podría continuar usando a start, a diferencia de si usamos stop en vez de interrupt

7. ¿Qué significa que un método sea synchronized?
Indica cómo afecta a la ejecución cuando varios hilos intentan acceder al mismo recurso.

un método synchronized impide que más de un hilo acceda a el, lo que afecta es que cuando un hilo entra a un método synchronized, este impide el acceso de más hilos, cuando el hilo termina o sale, se vuelve a abrir y pasa el siguiente y así hasta terminar.

8. Explica la diferencia entre sleep() e interrupt().
Indica qué ocurre cuando interrumpimos un hilo que está durmiendo.

sleep suspende durante un tiempo determinado un hilo o hasta que sea llamado, mientras que interrupt lo detiene completamente hasta que se vuelva a iniciar.

9. Dado el siguiente código, indica si produce o no una condición de carrera y por qué:

class Contador {
    public int valor = 0;
}

Contador c = new Contador();

Thread t1 = new Thread(() -> { for(int i = 0; i < 1000; i++) c.valor++; });
Thread t2 = new Thread(() -> { for(int i = 0; i < 1000; i++) c.valor++; });

t1.start();
t2.start();

no se produce la condición de carrera ya que los hilos no entran a ningún recurso compartido si no que cada uno instancia la clase contador por su cuenta.

10. Describe qué es la prioridad de un hilo (setPriority()) y cómo afecta realmente a la ejecución.

la prioridad es un valor entre 1 y 10, que dentro de la ejecución lo que hace es que los hilos con más prioridad se ejecuten antes, por ejemplo un hilo con prioridad 1, irá antes que uno con prioridad 2.

¿Es una garantía de orden? ¿Por qué puede comportarse de forma diferente según el sistema operativo?

no lo es, de hecho no es recomendable ajustar las prioridades a mano, ya que dependiendo de cosas como la carga del sistema esto no garantiza nada, de hecho los sistemas operativos más recientes están preparados para que un hilo no más recursos de la CPU de los necesarios.