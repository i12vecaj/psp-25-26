/**
Feedback JD - 11/12/2025
Fortalezas: Buen entendimiento general de hilos y condiciones de carrera; identificación correcta de la necesidad de synchronized para evitar conflictos.
Áreas de mejora: Confusión en la explicación de start() vs run() y sleep() vs interrupt(); yield() y prioridad de hilos necesitan mayor precisión; respuestas incompletas en algunas preguntas (p. ej., isAlive() y motivo de variación).
Recomendaciones: Revisar conceptos de concurrencia y métodos de control de hilos (yield(), interrupt(), sleep()), y clarificar diferencias entre ejecución secuencial y concurrente.
**/

1. Explica la diferencia entre los métodos start() y run() en un hilo.
Pon un ejemplo breve donde se vea la diferencia.
Básicamente la diferencia más notoria es que el método start() lanza el hilo y hasta que no acabe su el proceso del que se este encargando no deja al siguiente entrar en acción, 
en cambio el método run() hace que todos los hilos entren en ejecución al mismo tiempo

2. ¿Qué es una condición de carrera?
Describe qué la provoca y menciona una técnica para evitarla.
Cuando varios hilos intentan acceder al mismo recurso o a los mismos datos que lo que puede causar fallos

3. ¿Qué es el modelo Productor–Consumidor?
Indica qué problema resuelve y en qué casos se utiliza.
es un modelo donde el productor genera datos y los pone en una cola y luego el consumidor accede a esa cola y los procesa.
Que se produzca una condición de carrera


4. Observa el siguiente código y responde:

Thread t = new Thread(() -> {
    for (int i = 0; i < 5; i++) {
        System.out.println("A");
    }
});

t.start();

System.out.println(t.isAlive());

a) ¿Qué puede imprimir isAlive()?
True o False, en este caso devuelve True
b) ¿Por qué el resultado puede variar de una ejecución a otra?

5. ¿Para qué sirve el método yield()?
Explica por qué no garantiza orden de ejecución entre hilos.
Le dice al planificador que el hilo actual ceda la CPU


6. ¿Qué hace el método interrupt() en un hilo?
Indica cómo debería reaccionar un hilo bien programado cuando recibe una interrupción.
Interrumpe un hilo bloqueado o dormido


7. ¿Qué significa que un método sea synchronized?
Indica cómo afecta a la ejecución cuando varios hilos intentan acceder al mismo recurso.
el método synchronized hace que el 2 hilos no usen los mismos recursos o se "pisen" o se "roben" esos recursos
alguno de esos hilos se puede queda quedar un estado de dormido o en "espera" que no es la más óptimo

8. Explica la diferencia entre sleep() e interrupt().
Indica qué ocurre cuando interrumpimos un hilo que está durmiendo.
sleep() lo para por el tiempo que le digamos es decir temporalmente, mientras que interrupt() lo para de forma indefinida.

9. Dado el siguiente código, indica si produce o no una condición de carrera y por qué:

class Contador {
    public int valor = 0;
}

Contador c = new Contador();

Thread t1 = new Thread(() -> { for(int i = 0; i < 1000; i++) c.valor++; });
Thread t2 = new Thread(() -> { for(int i = 0; i < 1000; i++) c.valor++; });

t1.start();
t2.start();

Si se puede producir una condición de carrera, porque se esta compartiendo la variable y "valor++" no es atómico ya que en realidad son 3 operaciones(leer el valor, sumarle +1, y escribir el nuevo valor)

10. Describe qué es la prioridad de un hilo (setPriority()) y cómo afecta realmente a la ejecución.
¿Es una garantía de orden? ¿Por qué puede comportarse de forma diferente según el sistema operativo?
Hace que se le de más o menos CPU a un hilo, por lo que se le estaría dando más o menos recursos a ese hilo o proceso,
No, no es una garantía de orden sino de reparto de recursos
