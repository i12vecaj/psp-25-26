/**
Feedback JD - 11/12/2025
Fortalezas: Mejoría notable en la precisión de varias definiciones; explicaciones más claras y ordenadas; aciertos en isAlive(), yield() y condición de carrera; buen resumen del bloqueo con synchronized.
Áreas de mejora: La diferencia start()/run() sigue incompleta y sin ejemplo; Productor–Consumidor explicado sin colas ni límites de buffer; interrupt() mal entendido (no “mata” hilos); sleep() marcado como waiting cuando realmente es TIMED_WAITING; prioridad explicada de forma demasiado simple. Nombre de carpeta de entrega.
Recomendaciones: Añadir ejemplos breves donde se piden; revisar estados de un hilo en Java; estudiar interrupt(), wait/notify y Productor–Consumidor con buffer limitado para dominar concurrencia.
**/


1. Explica la diferencia entre los métodos start() y run() en un hilo.
Pon un ejemplo breve donde se vea la diferencia.

start() inicia el hilo y llama al método run() (al cual le solemos hacer un override)

run() ejecuta el hilo simplemente, sin concurrencia.

class Ejemplo {
    public int valorEjemplo = 0;

    @Override
    public void run() {
        for (int i = 0; i < 1000; i++) {
            valorEjemplo++;
        }
    }
}

No se me ocurre como ejemplificar esto pero para que se vea visualmente si ejecutamos con start()
se llamará al método run que hemos re-escrito
------------------------------------------------------------------------------------------------------------------------
2. ¿Qué es una condición de carrera?
Describe qué la provoca y menciona una técnica para evitarla.

La condición de carrera ocurre cuando dos hilos acceden al mismo recurso al mismo tiempo
como puede ser una variable, un archivo o una base de datos. El problema surge cuando
un hilo modifica el recurso y el otro lo lee, lo que puede dar lugar a resultados inesperados.

Para evitarla se puede usar el método synchronized que actua como bloqueo, atomicidad
o una implementación del modelo Productor–Consumidor
------------------------------------------------------------------------------------------------------------------------
3. ¿Qué es el modelo Productor–Consumidor?
Indica qué problema resuelve y en qué casos se utiliza.

El modelo Productor–Consumidor resuelve el problema de sincronización entre hilos. Su funcionamiento básicamente consiste en
que unos modelos crean y otros consumen, cuando no hay algo que consumir los hilos consumidores se van "a dormir" a la espera
de que haya algo consumible (se despiertan con notifyAll)
------------------------------------------------------------------------------------------------------------------------
4. Observa el siguiente código y responde:

Thread t = new Thread(() -> {
    for (int i = 0; i < 5; i++) {
        System.out.println("A");
    }
});

t.start();

System.out.println(t.isAlive());

a) ¿Qué puede imprimir isAlive()?
b) ¿Por qué el resultado puede variar de una ejecución a otra?

a) Puede imprimir true o false dependiendo de si el hilo está activo o no 
b) Porque puede variar de una ejecución a otra dependiendo de la prioridad del hilo, la aleatoriedad...
------------------------------------------------------------------------------------------------------------------------
5. ¿Para qué sirve el método yield()?
Explica por qué no garantiza orden de ejecución entre hilos.

El método yield() es como un ceda el paso y básicamente hace eso, cede "la ejecución" a otro hilo.
No garantiza el orden de ejecución porque el sistema puede ignorar este método y seguir ejecutando el hilo actual.
------------------------------------------------------------------------------------------------------------------------
6. ¿Qué hace el método interrupt() en un hilo?
Indica cómo debería reaccionar un hilo bien programado cuando recibe una interrupción.

Básicamente le dice/indica al hilo que tiene que interrumpirse. 
Un hilo BIEN programado debería interrumpirse (cerrarse) correctamente y de forma segura
------------------------------------------------------------------------------------------------------------------------
7. ¿Qué significa que un método sea synchronized?
Indica cómo afecta a la ejecución cuando varios hilos intentan acceder al mismo recurso.

Cuando a un método le agregamos el synchronized lo que ocurre es que solamente UN (1) hilo puede ejecutar ese método
de forma exclusiva, esto hace que se evite la condición de carrera.

Cuando varios hilos intenten acceder al mismo recurso lo que ocurrirá es que estará bloqueado hasta que
el hilo que lo esté usando termine su proceso y entonces se liberará el recurso.
------------------------------------------------------------------------------------------------------------------------
8. Explica la diferencia entre sleep() e interrupt().
Indica qué ocurre cuando interrumpimos un hilo que está durmiendo.

sleep() hace que el hilo se duerma por un tiempo determinado y su estado pase a waiting
interrupt() interrumpe el hilo y lo cierra de forma segura (estado muerto)

Al interrumpir un hilo que está durmiendo puede ocurrir lo siguiente:
- Puede saltar una excepción InterruptedException
- Puede interrumpirse de forma segura
------------------------------------------------------------------------------------------------------------------------
9. Dado el siguiente código, indica si produce o no una condición de carrera y por qué:

class Contador {
    public int valor = 0;
}

Contador c = new Contador();

Thread t1 = new Thread(() -> { for(int i = 0; i < 1000; i++) c.valor++; });
Thread t2 = new Thread(() -> { for(int i = 0; i < 1000; i++) c.valor++; });

t1.start();
t2.start();

Sí porque ambos hilos están modificando la misma variable valor al mismo tiempo.
------------------------------------------------------------------------------------------------------------------------
10. Describe qué es la prioridad de un hilo (setPriority()) y cómo afecta realmente a la ejecución.

¿Es una garantía de orden? ¿Por qué puede comportarse de forma diferente según el sistema operativo?

Al ponerle una prioridad a un hilo hará que la CPU le dediqué más importancia en la ejecución/procesamiento.
No es una garantía de orden ya que:
- Puede haber hilos con la misma prioridad y el sistema operativo puede ejecutarlos en cualquier orden
- La prioridad depende mucho del sistema operativo en resumen
------------------------------------------------------------------------------------------------------------------------
