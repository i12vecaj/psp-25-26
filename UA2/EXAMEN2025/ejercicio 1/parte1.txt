/**
Feedback JD - 11/12/2025
Fortalezas: Buen dominio general de los conceptos básicos de concurrencia; explicaciones claras en Productor–Consumidor, yield(), interrupt() y condición de carrera; estructura de respuestas cuidada y ejemplos razonados.
Áreas de mejora: La explicación de start() vs run() es poco precisa y el ejemplo no muestra concurrencia real; definición de condición de carrera algo confusa; algunos matices técnicos incompletos (isAlive(), prioridad de hilos, comportamiento detallado de interrupt()); documentación con frases redundantes o poco técnicas.
Recomendaciones: Añadir ejemplos de código que contrasten ejecución concurrente vs secuencial; depurar las definiciones usando terminología propia de concurrencia; reforzar conocimientos sobre planificación de hilos, atomicidad e interrupciones; ajustar el estilo hacia explicaciones más técnicas y menos narrativas. Formato de entrega carpeta y fichero mal establecidos.
**/

// Nota: 6.5 / 10


1. Explica la diferencia entre los métodos start() y run() en un hilo.
Pon un ejemplo breve donde se vea la diferencia.

Respuesta:
- start(): El metodo start crea un nuevo hilo y ejecuta run() en ese hilo.
- run(): Es donde esta el codigo que se va a ejecutar y se ejecuta en el hilo actual si se llama directamente.
Ejemplo:
Por ejemplo si tenemos: un fabrica y queremos poner en marcha muchos productos a fabricar primero creamos
los hilos con start() y luego en cada hilo se ejecuta el metodo run() que contiene la logica (el código) de fabricacion de los productos.

2. ¿Qué es una condición de carrera?
Describe qué la provoca y menciona una técnica para evitarla.

Respuesta:
Una condicion de carrera es cuando dos o mas hilos intenta modificar un recursos al mismo tiempo 
y este hace que de prioridad a uno o a otro.
Técnica para evitarla: usar synchronized para que solo un hilo pueda acceder a un recurso a la vez.

3. ¿Qué es el modelo Productor–Consumidor?
Indica qué problema resuelve y en qué casos se utiliza.

Respuesta:
El modelo Productor–Consumidor es el modelo que ayuda a que los hilos productores y consumidores
trabajen juntos sin que uno se quede esperando al otro.
problema:
Resuelve el problema de que si el productor produce más rápido que el consumidor, el buffer se llena
y el productor debe esperar. Si el consumidor consume más rápido, el buffer se vacía y el consumidor debe esperar.


4. Observa el siguiente código y responde:

Thread t = new Thread(() -> {
    for (int i = 0; i < 5; i++) {
        System.out.println("A");
    }
});

t.start();

System.out.println(t.isAlive());

a) ¿Qué puede imprimir isAlive()?
isAlive() puede imprimir si es true o si es false.
b) ¿Por qué el resultado puede variar de una ejecución a otra?
El resultado puede ser diferente porque depende de si el hilo "t" ha terminado la ejecución o no en el momento
en que se llama al metodo isAlive().

5. ¿Para qué sirve el método yield()?
Explica por qué no garantiza orden de ejecución entre hilos.

Respuesta:
El método yield() sirve para indicar al sistema operativo que el hilo actual 
puede ceder su turno a otros hilos de igual prioridad.
no garantiza orden de ejecución porque el sistema puede decidir
ignorar la sugerencia y continuar ejecutando el mismo hilo o elegir otro hilo.

6. ¿Qué hace el método interrupt() en un hilo?
Indica cómo debería reaccionar un hilo bien programado cuando recibe una interrupción.
Respuesta:
El método interrupt() envía una señal al hilo para que se interrumpa.
Los hilos deben comprobar periódicamente si han sido interrumpidos
y manejar las interruciones de manera correcta, por ejemplo, cuando limpiamos recursos con "finally()".

7. ¿Qué significa que un método sea synchronized?
Indica cómo afecta a la ejecución cuando varios hilos intentan acceder al mismo recurso.
Respuesta:
Un método synchronized significa que solo un hilo puede acceder a ese método a la vez.
Cuando varios hilos intentan acceder al mismo recurso, los demás hilos deben esperar
hasta que el hilo que está ejecutando el método synchronized termine.

8. Explica la diferencia entre sleep() e interrupt().
Indica qué ocurre cuando interrumpimos un hilo que está durmiendo.
Respuesta:
- sleep(): Hace que el hilo actual se detenga por un tiempo especificado. (por ejemplo 1000ms que equivale a 1 segundo)
- interrupt(): Envía una señal al hilo para que se interrumpa.
Cuando interrumpimos un hilo que está durmiendo (sleep()), el hilo lanza una "InterruptedException" y sale de sleep().

9. Dado el siguiente código, indica si produce o no una condición de carrera y por qué:

class Contador {
    public int valor = 0;
}

Contador c = new Contador();

Thread t1 = new Thread(() -> { for(int i = 0; i < 1000; i++) c.valor++; });
Thread t2 = new Thread(() -> { for(int i = 0; i < 1000; i++) c.valor++; });

t1.start();
t2.start();

Respuesta:
Sí, produce una condición de carrera.
El incremento (c.valor++) no es atómico,por lo que ambos hilos pueden leer y escribir simultáneamente,
perdiendo incrementos.

(atómico: que se realiza en una sola operación indivisible.)

10. Describe qué es la prioridad de un hilo (setPriority()) y cómo afecta realmente a la ejecución.

¿Es una garantía de orden? ¿Por qué puede comportarse de forma diferente según el sistema operativo?
Respuesta:
El setPriority() es el que da la importacia a un hilo frente a otro pero no garantiza que se ejecute antes.
su ejecucion afecta de manera que los hilos con mayor prioridad tienen más probabilidades de ser ejecutados
antes que los de menor prioridad, pero no es tan seguro.
Segun el algoritmo de cada uno de los sistemas operativo puede que no respete la prioridad.
